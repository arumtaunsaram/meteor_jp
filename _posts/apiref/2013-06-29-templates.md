---
layout: docs
title: "Meteor Kaiso - APIリファレンス: テンプレート API"
category: apiref
ref-official: 
  - title: Documentation
    title-jp: ドキュメント
    url: htt://docs.meteor.com/#templates_api
---

## テンプレート API

&lt;template name="foo"&gt; ... &lt;template&gt; のように宣言されたテンプレートは Template.foo 関数のように参照することができます。この関数が呼び出された際には HTML の文字列を返却します。

同じテンプレートが複数回ページにて出現します。そしてそれらの出現はテンプレートインスタンスと呼ばれます。テンプレートインスタンスには「作成中」、「ドキュメント組み込み済」そしてその後「ドキュメント離脱」「消滅」といったライフサイクルがあります。いつテンプレートインスタンスが削除されたのか、あるいは置き換えられたのか、そして後始末が必要なのかといった状態の判断を Meteor は開発者にかわり管理します。データをテンプレートインスタンスに関連付けることができ、ドキュメントに組み込まれた場合はDOMノードを参照することができます。

さらに Meteor は周りのHTMLが新しいDOMノードで再描画された場合でも、テンプレートインスタンスとその状態を維持します。テンプレートの呼び出し方が同じであっても、Meteor はインスタンスのノードが作成されたか消滅したかを考慮しません。preserve か定数領域を使うことで同じDOMノードを維持することを要求することができます。

名前が指定されたテンプレートに設定できる数々のコールバックと命令があり、それらはすべてのテンプレートのインスタンスに適用されます。下記にその詳細を記します。

*   [Template.myTemplate.](#Template_myTemplate)
    *   [rendered](#Template_myTemplate_rendered)
    *   [created](#Template_myTemplate_created)
    *   destroyed
    *   events
    *   helpers
    *   preserve
*   [テンプレートインスタンス](#Template_instances)
    *   this.findAll
    *   this.find
    *   this.firstNode
    *   this.lastNode
    *   this.data
*   [Meteor.render](#Meteor_render)
*   Meteor.renderList
*   [イベントマップ](#Template_Event_Maps)
*   [定数領域](#Template_Constant_regions)
*   [反応の隔離](#Template_Reactivity_isolation)


<dl>
  <dt>原文: <a href="http://docs.meteor.com/#templates_api">http://docs.meteor.com/#templates_api</a><dt>
  <dd>
  <ul>
    <li>[訳文の最終更新 2013/07/01 - 最新バージョンが0.6.4 の時点での内容]</li>
  </ul>
  </dd>
</dl>


---
<a name="Template_myTemplate"></a>
## Template.myTemplate([data])
__クライアントサイド__

HTMLを生成するにあたり、テンプレートを指定して実行します。

### 引数

* **data** オブジェクト

    省略可能。テンプレートを呼び出す際にデータを指定します。

テンプレートヘルパの中で呼び出された場合の Meteor.render の出力、あるいは反応可能なHTMLが存在する他の設定により呼びだされた場合、結果として出力されるHTML には反応可能なDOM要素として描画されるよう注釈がつきます。他の場合についてはHTMLに注釈はつかず静的となります。

---
<a name="Template_myTemplate_rendered"></a>
### Template.myTemplate.rendered = function () \{ ... \}
__クライアントサイド__

テンプレートのインスタンスが描画された時のコールバックを指定します。

このコールバックは Template.myTemplate がDOMノードに描画され、ドキュメントに組み込まれた際に一度呼ばれ、テンプレートのいずれかの部分が再描画された場合に再度呼び出されます。

コールバック関数の中身においては、this はテンプレートの出現に対し一意となるテンプレートのインスタンスで、再描画に渡り永続します。インスタンスオブジェクトの初期化と後始末については crteated と destroyed コールバックを使用してください。 

---
<a name="Template_myTemplate_created"></a>
### Template.myTemplate.created = function () \{ ... \}
__クライアントサイド__

テンプレートのインスタンスが生成された時のコールバックを指定します。

このコールバックは myTemplate の実行が新しいテンプレートの出現を示し、既に存在するテンプレートインスタンスの再描画ではない場合に呼び出されます。コールバック関数の中身においては、this は新たなテンプレートインスタンスオブジェクトです。このオブジェクトに設定したプロパティは rendered と destroyed コールバックとイベントハンドラより参照可能です。

このコールバックは一度呼ばれ、また一番最初に呼ばれるコールバックです。すべての created は対応する destroyed を持ちます。これはつまり、あるテンプレートインスタンスオブジェクトのインスタンスを created にて this より獲得したのならば、最終的に destroyed で同じオブジェクトを獲得することを意味します。

---
<a name="Template_myTemplate_preserve"></a>
### Template.myTemplate.preserve(selectors)
__クライアントサイド__

再描画の際に個々のDOM要素が保持されるルールを設定します。

### 引数

* **selectors** 配列あるいはオブジェクト

    配列の要素各々にて、多くとも1つの要素にマッチするCSSセレクタからなる \['.thing1', '.thing2'\] の様な配列。あるいはセレクタの辞書とノードの名前付けを行う関数 (下記をご確認ください)。

再描画の際にDOM要素を、既にドキュメントに組み込まれた要素を周りのHTMLが置換される時に残存させる形で保持することができます。テンプレートの再描画がテンプレートに含まれるテキストフィールド、iframe、そして他の神経質な要素に介入する必要がないと示すことができます。保持される要素は必ず古いDOMの中のノード、そして新しいHTMLの中のタグとして表現される必要があります。Meteor は保持された要素の周りのDOMを修正します。

*   デフォルト設定では、新しく生成された Meteor アプリケーションは preserve-input パッケージが含まれています。このパッケージは一意の id 属性を持つか 囲んでいるidを持つ要素の中で一意となる name 属性を持つ input、textarea、button、select、そして option 要素をすべて保持します。デフォルト設定は preserve-inputs パッケージを取り除くことで簡単に無効にできます。

DOM要素を元々と変わらないあるいは編集された要素に差し替えることで、現在の要素と異なる結果となる様々な場面にて保持機能は有効にはたらきます。これには下記のケースが含まれます。

*   テキスト入力フィールドと他のフォーム要素
*   CSSアニメーションが設定された要素
*   iframe
*   JavaScript のコードから参照されているノード

DOM全体、1つの要素とその子要素、Meteor によって描画されていないノード群を保持したい場合、かわりに [定数領域](#Template_Constant_regions) を使ってください。

ノードを保持するには、それぞれのセレクタがそのテンプレートの中の多くとも1つの要素にマッチするセレクタのリストを渡して下さい。テンプレートが再描画された際、セレクタは古いDOMと新しいDOMに対し評価が行われ、Meteor は周囲のHTMLを修正する際に古い要素を再利用します。

preserve の他の使い方は、引数にそれぞれのセレクタに対する名前付けの関数をとり、複数のノードに合致するセレクタを許可します。ノードの名前付け関数にはノードが渡されます。関数はそれぞれの要素に対し一意となる名前を表す文字列を返すか、保持対象から除外するのであれば false を返して下さい。

たとえば、テンプレートの中のid を持つすべての &lt;input&gt; 要素を保持するには下記のコードを使用してください。

~~~ javascript
Template.foo.preserve({
  'input[id]': function (node) { return node.id; }
});
~~~
    
セレクタはテンプレートのトップレベルをルートとして解釈されます。テンプレートの出現はそれぞれ独立して処理されるため、セレクタはページ全体を考慮する必要はなく、テンプレート一つの出現に対して一意としてください。セレクタはサブテンプレートの中のノードであってもマッチします。

ノードの保持機能を使っても、属性とコンテンツは保存され **ず** 新しいHTMLへと更新されます。テキストフィールドの文字はカーソラと選択範囲が触れられていない場合、テキストフィールドにフォーカスが当たっていなければ保持されません。iframe は遷移状態を保持し、アニメーションはパラメータが変更されない限り引き続き実行されます。

DOM API にそなわる制約によりノードが保存できないいくつかのケースがあります。たとえば、要素のタグ名を変更することはできません、そして親要素に対して相対となるようにや、他の保持されたノードになるような移動はできません。この様な理由から更新によって順序が変更されたり、親要素が変更されたノードは保持されません。

---
<a name="Template_instances"></a>
## テンプレートインスタンス

テンプレートインスタンスオブジェクトはドキュメントにおけるテンプレートの出現に相当します。DOMの参照に利用することができ、ページの再描画を通して維持される割り当てられたプロパティになることができます。

テンプレートインスタンスオブジェクトは、created、rendered そしてdestroyed テンプレートのコールバックの this の値として、そしてイベントハンドラの引数として参照することができます。

解説するプロパティと関数に加え、'_' で名前が始まるプロパティについては開発者にて使用できることが保証されています。オブジェクトの初期化あるいは後始末を行うには created あるいは destroyed コールバック関数を使用してください。

findAll、find、firstNode と lastNode へは rendered のコールバックとイベントハンドラからのみ参照することができます。テンプレートインスタンスがDOMの中に存在していることが前提のため、 created と destroyed から参照することはできません。

---
<a name="Meteor_render"></a>
## Meteor.render(htmlFunc)
__クライアントサイド__

データの変化に応じて自動的に更新するDOMノードを作成します。

### 引数

*   **htmlFunc** 関数

    HTMLの文字列を返す関数

描画されるHTMLを生成する関数。実行した直後に1度呼び出され、その後データが変更されると毎回再実行されます。関数のかわりにHTMLの文字列を指定することもできます。

Meteor.render はリアルタイムで自動的に更新される DocumentFragment (DOMノードの連続) を作成します。ほとんどの Meteor アプリケーションは直接呼び出す必要はなく、テンプレートを使用し、Meteor がレンダリングを処理を担当します。

引数にはHTML文字列を返す htmlFunc を指定して下さい。Meteor.render は引数に指定された関数を呼び出し、出力をDOMノードへ流し込みます。同時に、htmlFunc の引数として指定されたデータを追跡し、コールバックのつなぎ込みを自動的に行います。その結果、データの更新があった場合は毎回 htmlFunc の再実行と、その場でのDOMノードの更新がおこなわれるようになります。

返却された DocumentFragment はDOMのお好みの位置に直接挿入することができます。挿入されたノードは、画面から消えるまで更新されつづけます。その後は自動的に後始末が行われます。後始末の詳細については、Deps.flush を参照してください。

Meteor.render は反応可能な算出の中で htmlFunc を実行することにより、htmlFuncのデータ依存関係を追跡します。その結果として、利用されている任意の反応可能なデータソースの変更に対応することができます。詳細については、または反応可能なデータソースを自作する方法を学ぶにあたっては、反応可能性 (Reactivity) を参照してください。

例:

~~~ javascript
// クライアントサイド: オンラインのプレーヤ人数を表示します。
var frag = Meteor.render(function () {
  return "<p>" + Players.find({online: true}).count() +
    " 人のプレーヤがオンラインです。</p>";
});
document.body.appendChild(frag);

// サーバサイド: しばらく待機 (idle) 状態が続いているプレーヤを探し出し、
// それらのプレーヤをオフライン状態として登録します。
// クライアントの画面上に表示される人数は自動的に更新されます。
Players.update({idleTime: {$gt: 30}}, {$set: {online: false}});
~~~

---
<a name="Template_Event_Maps"></a>
## イベントマップ

いくつかの関数はイベントマップを保有します。イベントマップは、プロパティが扱うイベント群を指定し、値がそれらのイベントを扱うハンドラ群となったオブジェクトです。プロパティは次のいくつかの形式の中から1つを選ぶことができます。

*   **eventtype**

    'click' の様にイベントの種類でマッチします。

*   **eventtype selector**

    イベントの種類でマッチしますが、CSSセレクタにマッチする要素で発生した時のみです。

*   **event1, event2**

    同じハンドラ関数に1種類以上のイベントを指定します。カンマ区切りのリストを使用して下さい。

ハンドラ関数には次の2つの引数が渡されます。イベントに関する情報を保持する event、そしてハンドラが定義されたテンプレートのテンプレートインスタンスです。ハンドラ関数は現在イベントを扱っている要素のコンテキスト次第では、コンテキストに関する情報を this を使い参照することもできます。Handlebars のテンプレートでは、要素のコンテキストは #with や #each の様なブロックヘルパで指定された要素の Handlebar のデータコンテキストとなります。

例:

~~~ javascript
{
  // 要素をとわず、クリックされた時にハンドラ関数が呼び出されます
  'click': function (event) { ... },

  // 'accept' クラスの要素がクリックされた際にハンドラ関数が呼び出されます
  'click .accept': function (event) { ... },

  // 'accept' がクリックされるか、キーが押された時にハンドラ関数が呼び出されます
  'keydown, click .accept': function (event) { ... }
}
~~~

大抵のイベントは発生元の要素から、DOMツリーをつたい他の要素に伝達 (bubble up) されます。たとえば、'click p' はクリックがパラグラフ (訳注:&lt;p&gt;タグを指すものと考えられます) の中のリンク、span、あるいは他の要素で発生した場合であっても、パラグラフの中の要素で発生した click すべてを受け取ります。イベントの発生元となる要素は target プロパティを通して参照が可能です。一方で、セレクタにマッチし、それを現在処理しているハンドラの要素は currentTarget となります。

~~~ javascript
{
  'click p': function (event) {
    var paragraph = event.currentTarget; // いつでもp要素を指します
    var clickedElement = event.target; // p要素あるいは子要素の可能性があります
  }
}
~~~

セレクタがイベントが伝達している複数の要素にマッチする場合、複数回呼び出されます。例を挙げるならば 'click div' と 'click *' の場合などです。もしセレクタが指定されていない場合、ハンドラはイベント発生元に対して1回のみ呼び出されます。

ハンドラ関数に渡されるイベントオブジェクトにおいては、次のプロパティとメソッドが利用可能です。

*   **type** 文字列型

    "click", "blue" や "keypress" の様なイベントの種類

*   **target** DOM要素

    イベントの発生元の要素

*   **currentTarget** DOM要素

    イベントを現在処理している要素。イベントマップの中のセレクタにマッチした要素です。イベントの伝達を考慮した場合、target と同等かあるいは target の親世代となるでしょう。イベントの伝達とともに値は変化します。

*   **which** 数値

    マウスイベントの場合、マウスボタンの番号 (1=左、2=中、3=右) です。キーイベントの場合、文字あるいはキーコードです。

*   **stopPropagation()**

    イベントの親の他の要素への伝達を停止します。同じ要素に合致するセレクタを持つイベントマップがあれば、そのハンドラまでは呼び出しが行われます。

*   **stopImmediatePropagation()**

    このイベントマップの中の他のハンドラ、伝達により到達するハンドラ、他のイベントマップのハンドラを含めたイベントハンドラがこのイベントで実行されることを防ぎます。

*   **preventDefault()**

    リンクから遷移が発生したり、フォームを送信したりするなど、ブラウザが通常このイベントに対してとり行うアクションを停止します。他のハンドラはこの場合でも実行されますが、この処理を覆すことはできません。

*   **isPropagationStopped()**

    このイベントに対して stopPropagation() が実行されているかどうかを返却します。

*   **isImmediatePropagationStopped()**

    このイベントに対して stopImmediatePropagation() が実行されているかどうかを返却します。

*   **isDefaultPrevented()**

    このイベントに対して preventDefault() が実行されているかどうかを返却します。

ハンドラ関数から false を返却すると stopImmediatePropagation と preventDefault の両方をイベントに対して実行した事と同じ効果が得られます。

イベントの種類と利用方法は下記が含まれます。

*   **click**

    リンク、button、フォーム要素、div を含むすべての要素の上で発生したマウスクリックです。リンクのクリックから発生する遷移を防ぐ場合 preventDefault() を使ってください。いくつかのキーボードより要素をアクティブ化する方法からも click イベントが発生します。

*   **dbclick**

    ダブルクリック。

*   **focus, blur**

    テキスト入力欄あるいは他のフォーム要素がフォーカスを獲得あるいは喪失しました。tabindex プロパティを指定した要素であればフォーカスの移動が期待できます。リンク、チェックボックス、ラジオボタンが何もしない状態でフォーカス可能かはブラウザによって異なります。これらのイベントは伝達はおこなわれません。

*   **change**

    チェックボックスあるいはラジオボタンの状態が変化しました。テキストフィールドの場合 blue かキーイベントを使い変化に対応してください。

*   **mouseenter, mouseleave**

    ポインタが要素の領域に侵入した、あるいは離脱しました。これらのイベントは伝達はおこなわれません。

*   **mousedown, mouseup**

    マウスのボタンが新たに押下あるいは解放されました。

*   **keydown, keypress, keyup**

    ユーザがキーボードのキーを押しました。keypress はテキストフィールドの入力を捉える際に便利です。keydown と keyup は矢印キーかメタキーに利用することができます。

*   **tap**

    要素の上でのタップ。タッチ可能なデバイスでは click のかわりにすぐに実行されます。これらのイベントは touchmove と touchend を合成しています。

他のDOMイベントも同様に利用可能ですが、上記のイベントはすべてのブラウザで同じように動くよう、Meteor がいくらかの考慮をおこなってます。

---
<a name="Template_Constant_regions"></a>
## 定数領域

\{\{#constant\}\} ... \{\{/constant\}\} ブロックヘルパを使い、定数として作成されたテンプレートの領域は再描画が行われません。#constant ブロックヘルパのコンテンツは、それを含むテンプレートが再描画された場合でもそのままの状態で保存されます。テンプレートの他の部分の変更は preserve と同じ形で周囲の更新が行われます。個々のノードの保存とは異なり、定数領域はノードの同一性だけではなく、属性とコンテンツも保持されます。このブロックのコンテンツは周囲のテンプレートが表示された場合に一度評価が行われます。

定数領域を使うことで Meteor のテンプレートに Meteor に属さないコンテンツを埋め込むことができます。多くのサードパーティ製のウィジェットは独自のコードでDOMのノードの作成と管理を行います。ウィジェットあるいはライブラリが子要素を作成する空のエレメントをテンプレートの中に設置するのが典型的な形です。通常、Meteor が周囲のテンプレートを再描画する場合はテンプレートにおいて要素が空であったことを理由に、新たに生成された子要素は削除されます。一方コンテナが #constant ブロックに含まれていた場合、そのDOMの中のコンテンツに何が残されていたとしても立ち残されます。

*   **定数領域は Meteor に属さないコンテンツを埋め込むために設計されています。定数領域の中ではイベントハンドラと反応に必要な依存性は現在の所きちんと動きません。**

---
<a name="Template_Reactivity_isolation"></a>
## 反応の隔離

それぞれのテンプレートはテンプレートが保有する反応可能な算出にしたがい更新されます。テンプレートが Session.get やデータベースクエリの作成など、反応可能なデータソースにアクセスした際は、データの更新時にテンプレート全体の再描画が発生するデータの依存関係を生成します。これは一定の変更に対する再描画の回数が、HTML がテンプレートにどの様に分割されて格納されているかに左右されることを意味します。

基本的には、再描画の回数はそれほど重要ではありませんが、パフォーマンスの観点より、より細かい制御を行いたい場合、\{\{#isolate\}\} ... \{\{/isolate\}\} ヘルパを使用することができます。#isolate ブロック内に生成されたデータの依存関係はそのブロック内に限定され、その依存によって親のテンプレートが再描画されることはありません。ブロックヘルパを使うことで、新しいサブテンプレートにコンテンツを引き出すことによって得られる利益が実質的にもたらされます。
